---
title: "Paper Analyses"
author: "Marion Boisseaux"
date: "2023-04-11"
output: html_document
---

# Results

The importance of local habitat in shaping functional tropical tree species’ strategies.

Authors : *Marion Boisseaux*, Daniela  Krebber, Christopher Baraloto, Benoit Burban, Angela Casado-Garcia, Jocelyn Cazal, Jeanne Clément, Géraldine Derroire, Claire Fortunel, Jean-Yves Goret, Jonathan Heras, Gaelle Jaouen, Isabelle Maréchaux, Christine Scoffoni, Ghislain Vieilledent, Jason Vleminckx, Sabrina Coste, Heidy Schimann, Clément Stahl.


## Figure 1 - Contribution of the environment to single-trait variation 

```{r echo=FALSE, message=FALSE, warning=FALSE}
#library used
library(nlme) #to fit the model and do the variance partitioning with ML method
library(lme4) #for the VarCorr function
library(dplyr) #to pipe
library(ggplot2) #to plot
library(kableExtra) #to build nice tables

#data used (log on all traits)
Data <- read.csv("Dataset/OUTPUT_cleaning/Subset_imputed/Subset_imputation_exceptSD_18042023.csv") %>% 
  rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
  relocate(SD, .after = MajVLA) %>%
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Carbon", "Nitrogen", "Phosphorus", "Potassium", "TWI"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium", "TWI"), log) %>% 
  mutate(TLP = -TLP)

Data$Forest <- as.factor(Data$Forest)

#function for variance partitioning
Var_par <- function(Trait, Mydata){

  #Rename the trait column
  colnames(Mydata)[which(colnames(Mydata) == Trait)] <- "Trait"  
  
  # Fit the linear mixed-effects model
  model <- nlme::lme(Trait ~ TWI + Forest,  random=~1|Name, data = Mydata, na.action = na.omit, method = "ML")
  
  #Fit the associated null model with random intercept on species
  null_model <- nlme::lme(Trait~ 1,  random=~1|Name, data = Mydata, na.action = na.omit, method = "ML")
  
  # Extract the variance components 
  Var_components <-lme4::VarCorr(model)
  var_sp <- as.numeric(Var_components[1,1]) #for the random effects - species
  var_indv <- as.numeric(Var_components[2,1]) #model residual, also known as the intraspecific residual variance (linked to the individual but also error measures).
  
  # Obtain the variance of the random effect in the null model.
  random_variance_null <- as.numeric(lme4::VarCorr(null_model)[1,1])
  
  # Obtain the residual variance
  residual_variance_null <- as.numeric(lme4::VarCorr(null_model)[2,1])
  
  # Obtain the total variance of the null model
  v_0 <- random_variance_null + residual_variance_null
  
  # Calculate the variance component linked to the env't by substracting the residual variance of the model (var_indv) and the variance explained by the random factor, the species (var_sp), from the variance of the null model
 
  # Variance partitioning
  var_sp <- round(100 * var_sp / v_0)
  var_indv <- round(100 * var_indv / v_0)
  var_envt <- round(100 - (var_sp + var_indv))  # or it works also , var_envt <- v_0 - var_indv - var_sp Marion calcul
  
  Traits <- c(Trait, Trait, Trait)
  Levels <- c("Environment", "Species", "Individual")
  Variances <- c(var_envt,var_sp,var_indv)

  return(data.frame(Traits, Levels, Variances))
}

# Loop to calculate the variance partitioning for all traits
vars <- c()
#here we do for all species preferences but if interested for generalists only: Data <- Data %>% filter(Type != "Generalist")

for (i in colnames(Data)[9:17]){
  
  vars <- bind_rows(vars, Var_par(Trait = i, Mydata = Data))
  
}
#vars

#plot the results

vars$Levels <- as.factor(vars$Levels)
ordered_traits <- vars %>%
  filter(Levels == "Environment") %>%
  arrange(Variances) %>%
  pull(Traits)

vars$Traits <- factor(vars$Traits, levels = ordered_traits)

variance_plot<- vars %>%  
  mutate(Levels = factor(Levels, levels=c("Environment", "Species", "Individual"))) %>%
  mutate(Traits = dplyr::recode(Traits, "Gmin" = "g[min]")) %>% #recode gmin
  ggplot(aes(fill=Levels, y=Variances, x=Traits)) + 
  geom_bar(position="stack", stat="identity") +
  theme_minimal(base_size = 22) +
  ylab("") + xlab("")+
  theme(legend.text = element_text(face = "italic"),legend.position = "bottom") +
  scale_fill_manual("", values=c("#BBBBBB", "#CCBC44", "#029A88"),
                    breaks=c("Individual", "Species", "Environment"),
                    labels=c("Individual", "Species", "Environment"))  +
  coord_flip() +
  scale_x_discrete(labels = scales::label_parse())

variance_plot

#save plot
ggsave(filename = "Variance_partitioning.png", plot = variance_plot, bg = "white", width = 10, height = 8, dpi = 600)


##############################################
#function for plotting residuals distribution 
##############################################


# res_plot <- function(Trait, Mydata){
#   
#   #Rename the trait column
#   colnames(Mydata)[which(colnames(Mydata) == Trait)] <- "Trait"  
#   
#   
#   # Fit the linear mixed-effects model
#   model <- lmer(Trait ~ TWI + Forest + (1 | Name), data = Mydata)
#   plot <- qqnorm(resid(model), main= Trait)
#   
#   
#   return(plot)
# }
# 
# # Loop to plot residuals of the model for all traits
# 
# plotlist <- list()
# 
# for (i in colnames(Data)[9:17]){
#   
#   
#   plotlist[[i]] <- local({
#     
#     i <- i
#     
#     res_plot(i, Data)
#   })
#   
#   
# }

##############################
###Build coefficient table ###
##############################


#function for extracting the coefficient of the model
model_coef_table <- function(Trait, Mydata){

  #Rename the trait column
  colnames(Mydata)[which(colnames(Mydata) == Trait)] <- "Trait"  
  
  # Fit the linear mixed-effects model
  model <- nlme::lme(Trait ~ TWI + Forest,  random=~1|Name, data = Mydata, na.action = na.omit, method = "ML")
  
  # build coef table 
  coef_table <- coef(summary(model))
  coef_table <- as.data.frame(coef_table)
  
  return(coef_table)
}


# For all traits call model_coef_table function
coef_tables <- list()

for (i in colnames(Data)[9:17]){

  coef_tables[[i]] <- model_coef_table(i, Data)
}

# Combine all coefficient tables into one data frame
coef_table <- do.call(rbind, coef_tables)


# create nice table
coef_table %>%
  kbl(caption = "", escape = FALSE, digits = 3) %>%
  row_spec(0, bold = TRUE) %>% 
  kable_classic(full_width = F, html_font = "Cambria") %>%
  save_kable(file = "../Tables_SI/Model_summaries.png", zoom = 5)
```


The variance partitioning showed that single-trait values are largely determined by the species identity, i.e. interspecific variability and the individual level, i.e. intraspecific variability (Figure 1). The species explained between 35% (Potassium) and 69% (SD) of the variation. The residual variance corresponding to the intraspecific variation explained between 25% (SD) and 58% (Potassium). Intraspecific variation was higher than interspecific variation for gmin, carbon, potassium, and phosphorous leaf concentration. The environment explained very little of the variation: it was highest for gmin (11%) and potassium leaf concentration (7%) but even null for carbon leaf concentration. The model summary for each trait is shown in Table S6.

## Figure S8 & S10 - Traits covariation

```{r echo=FALSE, message=FALSE, warning=FALSE}

library(devtools)
library(ggfortify)
library(ggplot2)


###########################################
# Data preparation and log-transformation #
###########################################

Metradica_log <- read.csv("Dataset/OUTPUT_cleaning/Subset_imputed/Subset_imputation_exceptSD_18042023.csv") %>% 
  rename(Potassium = K, 
         Phosphorus = P, 
         Nitrogen = N,
         Carbon = C) %>% 
  relocate(SD, .after = MajVLA) %>%
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorus","Carbon", "Nitrogen", "Potassium", "TWI"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorus","Carbon", "Nitrogen", "Potassium", "TWI"), log) %>% 
  mutate(TLP = -TLP) 

############################
#Construction of golbal PCA#
############################
Data_PCA <- Metradica_log

Data_PCA$Type <-  dplyr::recode(Data_PCA$Type, BF='SF Specialist', TF= 'TF Specialist')
Data_PCA$Habitat <- dplyr::recode(Data_PCA$Habitat, BF='Seasonally flooded', TF= 'Terra firme')

PCA_type <- autoplot(princomp(~ Gmin + TLP + LSWC + MajVLA + Potassium + Phosphorus + Carbon + Nitrogen, data = Data_PCA, cor = T), #  If TRUE, the data will be centered and scaled before the analysis.
              data = Data_PCA, colour = "Type", alpha = 0.4, size = 2, shape = "Type",
              loadings = T, loadings.label = T, loadings.label.repel = T, 
              loadings.label.colour = 'black', loadings.colour = 'black',
              loadings.label.size = 4) +
  geom_hline(aes(yintercept = 0), col = 'black', linetype = "dotted") +
  geom_vline(aes(xintercept = 0), col = 'black', linetype = "dotted") +
  theme_classic(base_size = 10) +
  # scale_y_reverse() +
  scale_color_manual("Species' preferences", values = c("#009E72", "#56B4E9", "#E79F02")) +
  scale_shape_discrete("Species' preferences") +
  stat_ellipse(aes(col = Type), level = 0.85, size = 1.2)+
  guides(color = guide_legend(title = "Species' preferences", 
                              title.position = "top", 
                              nrow = 2, 
                              override.aes = list(size = 3)), 
         shape = guide_legend(override.aes = list(size = 3))) +
  theme(legend.position = "bottom")


PCA_collect <- autoplot(princomp(~ Gmin + TLP + LSWC + MajVLA + Potassium + Phosphorus + Carbon + Nitrogen, data = Data_PCA, cor = T), #  If TRUE, the data will be centered and scaled before the analysis.
                     data = Data_PCA, colour = "Habitat", alpha = 0.4, size = 2, shape = "Habitat",
                     loadings = T, loadings.label = T, loadings.label.repel = T, 
                     loadings.label.colour = 'black', loadings.colour = 'black',
                     loadings.label.size = 4) +
  geom_hline(aes(yintercept = 0), col = 'black', linetype = "dotted") +
  geom_vline(aes(xintercept = 0), col = 'black', linetype = "dotted") +
  theme_classic(base_size = 10) +
  # scale_y_reverse() +
  scale_color_manual("Habitat of collect", values = c("#56B4E9", "#E79F02", "")) +
  scale_shape_discrete("Habitat of collect") +
  stat_ellipse(aes(col = Habitat), level = 0.85, size = 1.2)+
  guides(color = guide_legend(title.position = "top", nrow = 3)) +
  theme(legend.position ="bottom")


#arrange plots together

plot_global_pca <- ggpubr::ggarrange(PCA_type, PCA_collect, labels = c("A", "B"), ncol = 2, nrow = 1, common.legend = FALSE, heights = c(4, 4))
#ggsave(filename = "PCA_full_Habitat_pref_collect_imputed.png", plot = plot_global_pca, bg = "white", width = 7, height = 4, dpi = 600)

plot_global_pca
```


Almost fifty percent of the variance in leaf trait values was explained by the first two axes of the PCA (Figure 2). All leaf chemical traits highly contributed to both axes, explaining most of the total trait variation. For the first axis, leaf chemical traits (phosphorus, nitrogen and potassium) and LSWC, respectively contributed up to 29 %, 20 %, 16 % and 17 % (Figure S5). For the second axis, leaf chemical traits (carbon, potassium) and TLP, respectively contributed up to 34 %, 27 % and 27 % (Figure S5). Interestingly, MajVLA and gmin were not well represented by the first two dimensions but contributed to the third dimension, respectively 49 % and 46 % (Figure S5). The third axis explained 13.5 % of the variation, but did not segregate species preferences nor habitats of collect (Figure S6). The permutational manova on species’ preferences revealed significant groups (Table S4A). We observe larger F-values for the pairwise post-hoc analyses between the SF specialists and generalists, indicating a more pronounced group separation than between TF specialist and generalists. The permutational manova on the habitat of collect, where the individual tree was sampled, revealed significant differences between the two habitats (Table S4B). 


## Figure 2 - Leaf trait syndrome variation along the TWI gradient

```{r generalist, eval=FALSE, include=FALSE}
###########################################
# Dividing the range of TWI into classes#
###########################################

library(devtools)
library(ggfortify)
library(ggplot2)

Metradica_log <- read.csv("Dataset/OUTPUT_cleaning/Subset_imputed/Subset_imputation_exceptSD_18042023.csv") %>% 
  rename(Potassium = K, 
         Phosphorous = P, 
         Nitrogen = N,
         Carbon = C) %>% 
  relocate(SD, .after = MajVLA) %>%
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorous","Carbon", "Nitrogen", "Potassium", "TWI"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorous","Carbon", "Nitrogen", "Potassium", "TWI"), log) %>% 
  mutate(TLP = -TLP) 

#Metradica_log <- Metradica_log %>% filter(Type != "Generalist") for specialists
Metradica_log <- Metradica_log %>% filter(Type == "Generalist") #for generalists
nb_class <- 8 #7 for specialists and then merge classes to get enough individuals per class
class_size <- (max(Metradica_log$TWI)-min(Metradica_log$TWI))/nb_class #each class have the same range of TWI
data <- as.data.frame(seq(1:nb_class))
colnames(data)[1] <- "class"
data$min <- c() #min TWI of the class
data$max <- c() #max TWI of the class
data$mean <- c() #mean TWI of the class
Metradica_log$class_TWI <- as.numeric(NA)

for (i in 1:nb_class){ #attribute the individuals of the dataset to each of the 8 classes
  
  data$min[i] <- min(Metradica_log$TWI) + (i-1) * class_size
  data$max[i] <- min(Metradica_log$TWI) +i * class_size
  data$mean[i] <- (data$max[i] + data$min[i])/2
  
  Metradica_log$class_TWI[which(Metradica_log$TWI <= data$max[i] & Metradica_log$TWI > data$min[i]) ] <- i
  
}

#attribute the individuals with the lowest TWI to the first class
Metradica_log$class_TWI[which(Metradica_log$TWI == data$min[1])]  <- 1

#merge TWI classes together to have approximately the same individuals per class

#Metradica_log$class_TWI[which(Metradica_log$class_TWI == 7)]  <- 6 #for specialists

Metradica_log$class_TWI[which(Metradica_log$class_TWI == 7)]  <- 6 #for generalists
Metradica_log$class_TWI[which(Metradica_log$class_TWI == 8)]  <- 6 #for generalists

table(Metradica_log$class_TWI) #number of individuals per class
table(is.na(Metradica_log$class_TWI)) #verify all individuals have a class

#in the data of classes, merge categories
#data$max[which(data$class == 6 )] <- data$max[which(data$class == 7)] #for specialists
data$max[which(data$class == 6 )] <- data$max[which(data$class == 8)] #for generalists
data$mean[which(data$class == 6 )] <- (data$max[6] + data$min[6])/2
data <- slice(data, 1:(n() - 2)) 
data

###################################################################################################
#Construction of the PCAs for each TWI class level and calculating the observed trait correlation
###################################################################################################

# Function to calculate the observed index values per community and the standardized index values by the associated null community

TI_index <- function(NbClass, Data, Data_TWI){ 
  #data that has a column named TWI as calculated before
  essai <- data.frame(TWI_class = numeric(), range_i = numeric(), sd_i = numeric()) #create an empty dataframe with columns

  for (i in 1:NbClass){  
    
    #calculate observed index
    
    Data_i <- Data %>% filter(class_TWI == i) #filter the data set for the first class of TWI
    
    res.pca_i <- PCA(Data_i %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
    
    range_i <- res.pca_i$eig[1,1] - res.pca_i$eig[8,1] #observed range of the eigen values
    
    sd_i <- sd(res.pca_i$eig[,1]) #observed standard deviation of the eigen values
    
    class_i <- c()
    class_i_sd <- c()
    indv_rich_i <- length(levels(as.factor(Data_i$Code)))
    indv_rich_total <- length(levels(as.factor(Data$Code)))
    for (i in 1:1000){  #sampling 1,000 random communities from the whole individual pool
      indv_list <- sample(levels(as.factor(Data$Code)), size = indv_rich_i, replace =FALSE) # sampling random individuals from the whole dataset, same number of individuals as the dataset of class TWI 1 
      Data_i_abon <- c() 
      for (s in 1:indv_rich_i){
        
        Data_i_abon <- rbind(Data_i_abon, 
                             Data[sample(which(Data$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 1 and getting all the characteristics (i.e. traits) for these individuals
      }
      
      PCA_comm_i <- PCA(Data_i_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
      class_i <- c(class_i, PCA_comm_i$eig[1,1] - PCA_comm_i$eig[8,1])
      class_i_sd <- c(class_i_sd , sd(PCA_comm_i$eig[,1]))
    }
    
      #Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
    ITI_i <- (range_i - mean(class_i)) / sd(class_i)
    ITI_i_sd <- (sd_i - mean(class_i_sd))/sd(class_i_sd)
    
    essai_i <- data.frame(range_i, sd_i, ITI_i, ITI_i_sd)
    essai <- rbind(essai, essai_i) 
    
   
  }

  #Plot ranges along TWI
  Data_TWI <- cbind(Data_TWI, essai)
  A <- ggplot(Data_TWI) +
    aes(x = mean, y = range_i) +
    geom_point(shape = "circle", size = 4, colour = "#112446") +
    theme_minimal()+
    ylab("Ranges")+
    xlab("")+
    theme(axis.text = element_text(size = 14),
          axis.title.y = element_text(size = 16),
          axis.title.x = element_text(size = 16))
  
  #Plot SD along TWI
  B <- ggplot(Data_TWI) +
    aes(x = mean, y = sd_i) +
    geom_point(shape = "circle", size = 4, colour = "#112446") +
    theme_minimal()+
    ylab("sd")+
    xlab("")+
    theme(axis.text = element_text(size = 14),
          axis.title.y = element_text(size = 16),
          axis.title.x = element_text(size = 16))
  
  
  #Plot TI (ranges standardized by effect size) along TWI 
  C <- ggplot(Data_TWI) +
    aes(x = mean, y = ITI_i) +
    geom_point(shape = "circle", size = 5, aes(color = mean)) +
    scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
    geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
    ylab(expression(atop("Trait integration index", italic("range")))) + #atop creates a line break
    xlab("Topographic wetness index") +
    theme(axis.text = element_text(size = 12),
          axis.title.y = element_text(size = 12),
          axis.title.x = element_text(size = 12)) +
    theme_minimal(base_size = 12) +
    guides(color = "none") #remove legend
  
  
  #Plot TI_sd along TWI
  D <- ggplot(Data_TWI) +
    aes(x = mean, y = ITI_i_sd) +
    geom_point(shape = "circle", size = 5, aes(color = mean)) +
    scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
    geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
    ylab(expression(atop("Trait integration index", italic("standard deviation")))) +
    xlab("Topographic wetness index") +
    theme(axis.text = element_text(size = 12),
          axis.title.y = element_text(size = 12),
          axis.title.x = element_text(size = 12)) +
    theme_minimal(base_size = 12)+
    guides(color = "none")
  
  
  #arrange plots together
  E <- ggpubr::ggarrange(A, B, C, D, labels = c("A", "B", "C", "D"), ncol = 2, nrow = 2, common.legend = TRUE)
  plot_publi <- ggpubr::ggarrange(C, D, labels = c("A", "B"), ncol = 2, nrow = 1, common.legend = TRUE)
  
  
  
  #save plot
  ggsave(filename = "Multivariate covariation_6_class_generalist.png", plot = plot_publi, bg = "white", width = 7, height = 4, dpi = 600)
    ggsave(filename = "Multivariate covariation_6_class_4plot_generalist.png", plot = E, bg = "white", width = 7, height = 4, dpi = 600)
  return(list(essai, A, B, C, D, E, plot_publi))
  
 }


#1------------

Data_1 <- Metradica_log %>% filter(class_TWI == 1) #filter the data set for the first class of TWI
res.pca_1 <- PCA(Data_1 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_1$eig #look at the eigen values 
range_1 <- res.pca_1$eig[1,1] - res.pca_1$eig[8,1] #observed range of the eigen values
sd_1 <- sd(res.pca_1$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_1, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#########################################################################
#Construction of the null associated community for each TWI class level 
#########################################################################

class_1 <- c()
class_1_sd <- c()
indv_rich_1 <- length(levels(as.factor(Data_1$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole individual pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_1, replace =FALSE) # sampling random individuals from the whole dataset, same number of individuals as the dataset of class TWI 1 
  Data_1_abon <- c() 
  for (s in 1:indv_rich_1){
      
      Data_1_abon <- rbind(Data_1_abon, 
                           Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 1 and getting all the characteristics (i.e. traits) for these individuals
    }

  PCA_comm_1 <- PCA(Data_1_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_1 <- c(class_1, PCA_comm_1$eig[1,1] - PCA_comm_1$eig[8,1])
  class_1_sd <- c(class_1_sd , sd(PCA_comm_1$eig[,1]))
}

plot_1 <- hist(class_1)

#Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
ITI_1 <- (range_1 - mean(class_1)) / sd(class_1)
ITI_1_sd <- (sd_1 - mean(class_1_sd))/sd(class_1_sd)

#2--------------------------

Data_2 <- Metradica_log %>% filter(class_TWI == 2) #filter the data set for the first class of TWI
res.pca_2 <- PCA(Data_2 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_2$eig #look at the eigen values 
range_2 <- res.pca_2$eig[1,1] - res.pca_2$eig[8,1] #observed range of the eigen values
sd_2 <- sd(res.pca_2$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_2, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_2
class_2 <- c()
class_2_sd <- c()
indv_rich_2 <- length(levels(as.factor(Data_2$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_2, replace =FALSE) # first null community for class TWI 2 sampled from the whole dataset
  Data_2_abon <- c()
  for (s in 1:indv_rich_2){
      
      Data_2_abon <- rbind(Data_2_abon, 
                           Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 2 
    }
  
  PCA_comm_2 <- PCA(Data_2_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_2 <- c(class_2, PCA_comm_2$eig[1,1] - PCA_comm_2$eig[8,1])
  class_2_sd <- c(class_2_sd , sd(PCA_comm_2$eig[,1]))
}

plot_2 <- hist(class_2)

#Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
ITI_2 <- (range_2 - mean(class_2)) / sd(class_2)
ITI_2_sd <- (sd_2 - mean(class_2_sd))/sd(class_2_sd)

#3--------------

Data_3 <- Metradica_log %>% filter(class_TWI == 3) #filter the data set for the first class of TWI
res.pca_3 <- PCA(Data_3 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_3$eig #look at the eigen values 
range_3 <- res.pca_3$eig[1,1] - res.pca_3$eig[8,1] #observed range of the eigen values
sd_3 <- sd(res.pca_3$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_3, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_3
class_3 <- c()
class_3_sd <- c()
indv_rich_3 <- length(levels(as.factor(Data_3$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_3, replace =FALSE) # first null community for class TWI 3 sampled from the whole dataset
  Data_3_abon <- c()
  for (s in 1:indv_rich_3){
    
    Data_3_abon <- rbind(Data_3_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 3 
  }
  
  PCA_comm_3 <- PCA(Data_3_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_3 <- c(class_3, PCA_comm_3$eig[1,1] - PCA_comm_3$eig[8,1])
  class_3_sd <- c(class_3_sd , sd(PCA_comm_3$eig[,1]))
}

plot_3 <- hist(class_3)

ITI_3 <- (range_3 - mean(class_3))/sd(class_3)
ITI_3_sd <- (sd_3 - mean(class_3_sd))/sd(class_3_sd)

#4------------
Data_4 <- Metradica_log %>% filter(class_TWI == 4) #filter the data set for the first class of TWI
res.pca_4 <- PCA(Data_4 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_4$eig #look at the eigen values 
range_4 <- res.pca_4$eig[1,1] - res.pca_4$eig[8,1] #observed range of the eigen values
sd_4 <- sd(res.pca_4$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_4, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_4
class_4 <- c()
class_4_sd <- c()
indv_rich_4 <- length(levels(as.factor(Data_4$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_4, replace =FALSE) # first null community for class TWI 4 sampled from the whole dataset
  Data_4_abon <- c()
  for (s in 1:indv_rich_4){
    
    Data_4_abon <- rbind(Data_4_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 4 
  }
  
  PCA_comm_4 <- PCA(Data_4_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_4 <- c(class_4, PCA_comm_4$eig[1,1] - PCA_comm_4$eig[8,1])
  class_4_sd <- c(class_4_sd , sd(PCA_comm_4$eig[,1]))
}

plot_4 <- hist(class_4)

ITI_4 <- (range_4 - mean(class_4))/sd(class_4)
ITI_4_sd <- (sd_4 - mean(class_4_sd))/sd(class_4_sd)

#5----------
Data_5 <- Metradica_log %>% filter(class_TWI == 5) #filter the data set for the first class of TWI
res.pca_5 <- PCA(Data_5 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_5$eig #look at the eigen values 
range_5 <- res.pca_5$eig[1,1] - res.pca_5$eig[8,1] #observed range of the eigen values
sd_5 <- sd(res.pca_5$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_5, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_5
class_5 <- c()
class_5_sd <- c()
indv_rich_5 <- length(levels(as.factor(Data_5$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_5, replace =FALSE) # first null community for class TWI 5 sampled from the whole dataset
  Data_5_abon <- c()
  for (s in 1:indv_rich_5){
    
    Data_5_abon <- rbind(Data_5_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 5 
  }
  
  PCA_comm_5 <- PCA(Data_5_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_5 <- c(class_5, PCA_comm_5$eig[1,1] - PCA_comm_5$eig[8,1])
  class_5_sd <- c(class_5_sd , sd(PCA_comm_5$eig[,1]))
}

plot_5 <- hist(class_5)

ITI_5 <- (range_5 - mean(class_5))/sd(class_5)
ITI_5_sd <- (sd_5 - mean(class_5_sd))/sd(class_5_sd)
#6----------------

Data_6 <- Metradica_log %>% filter(class_TWI == 6) #filter the data set for the first class of TWI
res.pca_6 <- PCA(Data_6 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_6$eig #look at the eigen values 
range_6 <- res.pca_6$eig[1,1] - res.pca_6$eig[8,1] #observed range of the eigen values
sd_6 <- sd(res.pca_6$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_6, addlabels = TRUE, ylim = c(0, 60)) #visualization of the scree plot

#null community associated to the Data_6
class_6 <- c()
class_6_sd <- c()
indv_rich_6 <- length(levels(as.factor(Data_6$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_6, replace =FALSE) # first null community for class TWI 6 sampled from the whole dataset
  Data_6_abon <- c()
  for (s in 1:indv_rich_6){
    
    Data_6_abon <- rbind(Data_6_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 6 
  }
  
  PCA_comm_6 <- PCA(Data_6_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_6 <- c(class_6, PCA_comm_6$eig[1,1] - PCA_comm_6$eig[8,1])
  class_6_sd <- c(class_6_sd , sd(PCA_comm_6$eig[,1]))
}

plot_6 <- hist(class_6)

ITI_6 <- (range_6 - mean(class_6))/sd(class_6)
ITI_6_sd <- (sd_6 - mean(class_6_sd))/sd(class_6_sd)

#####################
#Plots
#####################
 #data for generalists
data$ranges <- c(range_1, range_2, range_3, range_4, range_5, range_6)
data$sd <- c(sd_1, sd_2, sd_3, sd_4, sd_5, sd_6)
data$ITI <- c(ITI_1, ITI_2, ITI_3, ITI_4, ITI_5, ITI_6)
data$ITI_sd <- c(ITI_1_sd, ITI_2_sd, ITI_3_sd, ITI_4_sd, ITI_5_sd, ITI_6_sd)

#write.csv(data, "./Results/TI/data_generalist.csv")
```

```{r generalist plot, message=FALSE, warning=FALSE, include=FALSE}
###########################################
library(ggpubr)

#read previously saved file for the generalist
data <- read.csv("./Results/TI/data_generalist.csv")

#plot generalists

title <- "Generalist"

# Create a text grob
tgrob <- ggpubr::text_grob(title,size = 16)
# Draw the text
plot_0 <- as_ggplot(tgrob) + theme(plot.margin = margin(0,3,0,0, "cm"))


#Plot TI (ranges standardized by effect size) along TWI 
A <- ggplot(data) +
  aes(x = mean, y = ITI, ymax= ITI, ymin= 0) +
  geom_pointrange(shape = "circle", size = 1, color = "#009E72") +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
  ylab(expression(atop("Trait integration index", italic("range")))) + #atop creates a line break
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12)) +
  theme_minimal(base_size = 12) +
  guides(color = "none") +#remove legend
ylim(-4, 6)+
  xlim(1.7, 2.6)
A

#Plot TI_sd along TWI
B <- ggplot(data) +
  aes(x = mean, y = ITI_sd, ymax= ITI_sd, ymin=0) +
  geom_pointrange(shape = "circle", size = 1, color = "#009E72") +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
  ylab(expression(atop("Trait integration index", italic("standard deviation")))) +
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12)) +
  theme_minimal(base_size = 12)+
  guides(color = "none")+
  ylim(-4, 6)+
  xlim(1.7, 2.6)
B
```


```{r specialist, eval=FALSE, include=FALSE}
###########################################
# Dividing the range of TWI into classes#
###########################################


library(devtools)
library(ggfortify)
library(ggplot2)

Metradica_log <- read.csv("Dataset/OUTPUT_cleaning/Subset_imputed/Subset_imputation_exceptSD_18042023.csv") %>% 
  rename(Potassium = K, 
         Phosphorous = P, 
         Nitrogen = N,
         Carbon = C) %>% 
  relocate(SD, .after = MajVLA) %>%
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorous","Carbon", "Nitrogen", "Potassium", "TWI"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Phosphorous","Carbon", "Nitrogen", "Potassium", "TWI"), log) %>% 
  mutate(TLP = -TLP) 

Metradica_log <- Metradica_log %>% filter(Type != "Generalist") #for specialists

nb_class <- 7 # for specialists and then merge classes to get enough individuals per class
class_size <- (max(Metradica_log$TWI)-min(Metradica_log$TWI))/nb_class #each class have the same range of TWI
data <- as.data.frame(seq(1:nb_class))
colnames(data)[1] <- "class"
data$min <- c() #min TWI of the class
data$max <- c() #max TWI of the class
data$mean <- c() #mean TWI of the class
Metradica_log$class_TWI <- as.numeric(NA)

for (i in 1:nb_class){ #attribute the individuals of the dataset to each of the 8 classes
  
  data$min[i] <- min(Metradica_log$TWI) + (i-1) * class_size
  data$max[i] <- min(Metradica_log$TWI) +i * class_size
  data$mean[i] <- (data$max[i] + data$min[i])/2
  
  Metradica_log$class_TWI[which(Metradica_log$TWI <= data$max[i] & Metradica_log$TWI > data$min[i]) ] <- i
  
}

#attribute the individuals with the lowest TWI to the first class
Metradica_log$class_TWI[which(Metradica_log$TWI == data$min[1])]  <- 1

#merge TWI classes together to have approximately the same individuals per class

Metradica_log$class_TWI[which(Metradica_log$class_TWI == 7)]  <- 6 #for specialists


table(Metradica_log$class_TWI) #number of individuals per class
table(is.na(Metradica_log$class_TWI)) #verify all individuals have a class

#in the data of classes, merge categories
data$max[which(data$class == 6 )] <- data$max[which(data$class == 7)] #for specialists
data$mean[which(data$class == 6 )] <- (data$max[6] + data$min[6])/2
data <- slice(data, 1:(n() - 1)) 
data

###################################################################################################
#Construction of the PCAs for each TWI class level and calculating the observed trait correlation
###################################################################################################

# Function to calculate the observed index values per community and the standardized index values by the associated null community

TI_index <- function(NbClass, Data, Data_TWI){ 
  #data that has a column named TWI as calculated before
  essai <- data.frame(TWI_class = numeric(), range_i = numeric(), sd_i = numeric()) #create an empty dataframe with columns

  for (i in 1:NbClass){  
    
    #calculate observed index
    
    Data_i <- Data %>% filter(class_TWI == i) #filter the data set for the first class of TWI
    
    res.pca_i <- PCA(Data_i %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
    
    range_i <- res.pca_i$eig[1,1] - res.pca_i$eig[8,1] #observed range of the eigen values
    
    sd_i <- sd(res.pca_i$eig[,1]) #observed standard deviation of the eigen values
    
    class_i <- c()
    class_i_sd <- c()
    indv_rich_i <- length(levels(as.factor(Data_i$Code)))
    indv_rich_total <- length(levels(as.factor(Data$Code)))
    for (i in 1:1000){  #sampling 1,000 random communities from the whole individual pool
      indv_list <- sample(levels(as.factor(Data$Code)), size = indv_rich_i, replace =FALSE) # sampling random individuals from the whole dataset, same number of individuals as the dataset of class TWI 1 
      Data_i_abon <- c() 
      for (s in 1:indv_rich_i){
        
        Data_i_abon <- rbind(Data_i_abon, 
                             Data[sample(which(Data$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 1 and getting all the characteristics (i.e. traits) for these individuals
      }
      
      PCA_comm_i <- PCA(Data_i_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
      class_i <- c(class_i, PCA_comm_i$eig[1,1] - PCA_comm_i$eig[8,1])
      class_i_sd <- c(class_i_sd , sd(PCA_comm_i$eig[,1]))
    }
    
      #Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
    ITI_i <- (range_i - mean(class_i)) / sd(class_i)
    ITI_i_sd <- (sd_i - mean(class_i_sd))/sd(class_i_sd)
    
    essai_i <- data.frame(range_i, sd_i, ITI_i, ITI_i_sd)
    essai <- rbind(essai, essai_i) 
    
   
  }

  #Plot ranges along TWI
  Data_TWI <- cbind(Data_TWI, essai)
  A <- ggplot(Data_TWI) +
    aes(x = mean, y = range_i) +
    geom_point(shape = "circle", size = 4, colour = "#112446") +
    theme_minimal()+
    ylab("Ranges")+
    xlab("")+
    theme(axis.text = element_text(size = 14),
          axis.title.y = element_text(size = 16),
          axis.title.x = element_text(size = 16))
  
  #Plot SD along TWI
  B <- ggplot(Data_TWI) +
    aes(x = mean, y = sd_i) +
    geom_point(shape = "circle", size = 4, colour = "#112446") +
    theme_minimal()+
    ylab("sd")+
    xlab("")+
    theme(axis.text = element_text(size = 14),
          axis.title.y = element_text(size = 16),
          axis.title.x = element_text(size = 16))
  
  
  #Plot TI (ranges standardized by effect size) along TWI 
  C <- ggplot(Data_TWI) +
    aes(x = mean, y = ITI_i) +
    geom_pointrange(shape = "circle", size = 2, aes(color = mean)) +
    scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
    geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
    ylab(expression(atop("Trait integration index", italic("range")))) + #atop creates a line break
    xlab("Topographic wetness index") +
    theme(axis.text = element_text(size = 12),
          axis.title.y = element_text(size = 12),
          axis.title.x = element_text(size = 12)) +
    theme_minimal(base_size = 12) +
    guides(color = "none") #remove legend
  
  
  #Plot TI_sd along TWI
  D <- ggplot(Data_TWI) +
    aes(x = mean, y = ITI_i_sd) +
    geom_point(shape = "circle", size = 5, aes(color = mean)) +
    scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
    geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
    ylab(expression(atop("Trait integration index", italic("standard deviation")))) +
    xlab("Topographic wetness index") +
    theme(axis.text = element_text(size = 12),
          axis.title.y = element_text(size = 12),
          axis.title.x = element_text(size = 12)) +
    theme_minimal(base_size = 12)+
    guides(color = "none")
  
  
  #arrange plots together
  E <- ggpubr::ggarrange(A, B, C, D, labels = c("A", "B", "C", "D"), ncol = 2, nrow = 2, common.legend = TRUE)
  plot_publi <- ggpubr::ggarrange(C, D, labels = c("A", "B"), ncol = 2, nrow = 1, common.legend = TRUE)
  
  
  
  #save plot
  ggsave(filename = "Multivariate covariation_6_class_specialist.png", plot = plot_publi, bg = "white", width = 7, height = 4, dpi = 600)
    ggsave(filename = "Multivariate covariation_6_class_4plot_specialist.png", plot = E, bg = "white", width = 7, height = 4, dpi = 600)
  return(list(essai, A, B, C, D, E, plot_publi))
  
 }


#1------------

Data_1 <- Metradica_log %>% filter(class_TWI == 1) #filter the data set for the first class of TWI
res.pca_1 <- PCA(Data_1 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_1$eig #look at the eigen values 
range_1 <- res.pca_1$eig[1,1] - res.pca_1$eig[8,1] #observed range of the eigen values
sd_1 <- sd(res.pca_1$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_1, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#########################################################################
#Construction of the null associated community for each TWI class level 
#########################################################################

class_1 <- c()
class_1_sd <- c()
indv_rich_1 <- length(levels(as.factor(Data_1$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole individual pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_1, replace =FALSE) # sampling random individuals from the whole dataset, same number of individuals as the dataset of class TWI 1 
  Data_1_abon <- c() 
  for (s in 1:indv_rich_1){
      
      Data_1_abon <- rbind(Data_1_abon, 
                           Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 1 and getting all the characteristics (i.e. traits) for these individuals
    }

  PCA_comm_1 <- PCA(Data_1_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_1 <- c(class_1, PCA_comm_1$eig[1,1] - PCA_comm_1$eig[8,1])
  class_1_sd <- c(class_1_sd , sd(PCA_comm_1$eig[,1]))
}

plot_1 <- hist(class_1)

#Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
ITI_1 <- (range_1 - mean(class_1)) / sd(class_1)
ITI_1_sd <- (sd_1 - mean(class_1_sd))/sd(class_1_sd)

#2--------------------------

Data_2 <- Metradica_log %>% filter(class_TWI == 2) #filter the data set for the first class of TWI
res.pca_2 <- PCA(Data_2 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_2$eig #look at the eigen values 
range_2 <- res.pca_2$eig[1,1] - res.pca_2$eig[8,1] #observed range of the eigen values
sd_2 <- sd(res.pca_2$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_2, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_2
class_2 <- c()
class_2_sd <- c()
indv_rich_2 <- length(levels(as.factor(Data_2$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_2, replace =FALSE) # first null community for class TWI 2 sampled from the whole dataset
  Data_2_abon <- c()
  for (s in 1:indv_rich_2){
      
      Data_2_abon <- rbind(Data_2_abon, 
                           Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 2 
    }
  
  PCA_comm_2 <- PCA(Data_2_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_2 <- c(class_2, PCA_comm_2$eig[1,1] - PCA_comm_2$eig[8,1])
  class_2_sd <- c(class_2_sd , sd(PCA_comm_2$eig[,1]))
}

plot_2 <- hist(class_2)

#Calculating the multivariate covariation  between traits index, standardized by the effect size since the comparison between groups is likely to be biased by the number of individuals used. 
ITI_2 <- (range_2 - mean(class_2)) / sd(class_2)
ITI_2_sd <- (sd_2 - mean(class_2_sd))/sd(class_2_sd)

#3--------------

Data_3 <- Metradica_log %>% filter(class_TWI == 3) #filter the data set for the first class of TWI
res.pca_3 <- PCA(Data_3 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_3$eig #look at the eigen values 
range_3 <- res.pca_3$eig[1,1] - res.pca_3$eig[8,1] #observed range of the eigen values
sd_3 <- sd(res.pca_3$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_3, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_3
class_3 <- c()
class_3_sd <- c()
indv_rich_3 <- length(levels(as.factor(Data_3$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_3, replace =FALSE) # first null community for class TWI 3 sampled from the whole dataset
  Data_3_abon <- c()
  for (s in 1:indv_rich_3){
    
    Data_3_abon <- rbind(Data_3_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 3 
  }
  
  PCA_comm_3 <- PCA(Data_3_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_3 <- c(class_3, PCA_comm_3$eig[1,1] - PCA_comm_3$eig[8,1])
  class_3_sd <- c(class_3_sd , sd(PCA_comm_3$eig[,1]))
}

plot_3 <- hist(class_3)

ITI_3 <- (range_3 - mean(class_3))/sd(class_3)
ITI_3_sd <- (sd_3 - mean(class_3_sd))/sd(class_3_sd)

#4------------
Data_4 <- Metradica_log %>% filter(class_TWI == 4) #filter the data set for the first class of TWI
res.pca_4 <- PCA(Data_4 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_4$eig #look at the eigen values 
range_4 <- res.pca_4$eig[1,1] - res.pca_4$eig[8,1] #observed range of the eigen values
sd_4 <- sd(res.pca_4$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_4, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_4
class_4 <- c()
class_4_sd <- c()
indv_rich_4 <- length(levels(as.factor(Data_4$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_4, replace =FALSE) # first null community for class TWI 4 sampled from the whole dataset
  Data_4_abon <- c()
  for (s in 1:indv_rich_4){
    
    Data_4_abon <- rbind(Data_4_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 4 
  }
  
  PCA_comm_4 <- PCA(Data_4_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_4 <- c(class_4, PCA_comm_4$eig[1,1] - PCA_comm_4$eig[8,1])
  class_4_sd <- c(class_4_sd , sd(PCA_comm_4$eig[,1]))
}

plot_4 <- hist(class_4)

ITI_4 <- (range_4 - mean(class_4))/sd(class_4)
ITI_4_sd <- (sd_4 - mean(class_4_sd))/sd(class_4_sd)

#5----------
Data_5 <- Metradica_log %>% filter(class_TWI == 5) #filter the data set for the first class of TWI
res.pca_5 <- PCA(Data_5 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_5$eig #look at the eigen values 
range_5 <- res.pca_5$eig[1,1] - res.pca_5$eig[8,1] #observed range of the eigen values
sd_5 <- sd(res.pca_5$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_5, addlabels = TRUE, ylim = c(0, 50)) #visualization of the scree plot

#null community associated to the Data_5
class_5 <- c()
class_5_sd <- c()
indv_rich_5 <- length(levels(as.factor(Data_5$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_5, replace =FALSE) # first null community for class TWI 5 sampled from the whole dataset
  Data_5_abon <- c()
  for (s in 1:indv_rich_5){
    
    Data_5_abon <- rbind(Data_5_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 5 
  }
  
  PCA_comm_5 <- PCA(Data_5_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_5 <- c(class_5, PCA_comm_5$eig[1,1] - PCA_comm_5$eig[8,1])
  class_5_sd <- c(class_5_sd , sd(PCA_comm_5$eig[,1]))
}

plot_5 <- hist(class_5)

ITI_5 <- (range_5 - mean(class_5))/sd(class_5)
ITI_5_sd <- (sd_5 - mean(class_5_sd))/sd(class_5_sd)
#6----------------

Data_6 <- Metradica_log %>% filter(class_TWI == 6) #filter the data set for the first class of TWI
res.pca_6 <- PCA(Data_6 %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE) #PCA on trait values except SD, that are scaled to unit variance
res.pca_6$eig #look at the eigen values 
range_6 <- res.pca_6$eig[1,1] - res.pca_6$eig[8,1] #observed range of the eigen values
sd_6 <- sd(res.pca_6$eig[,1]) #observed standard deviation of the eigen values
fviz_eig(res.pca_6, addlabels = TRUE, ylim = c(0, 60)) #visualization of the scree plot

#null community associated to the Data_6
class_6 <- c()
class_6_sd <- c()
indv_rich_6 <- length(levels(as.factor(Data_6$Code)))
indv_rich_total <- length(levels(as.factor(Metradica_log$Code)))
for (i in 1:1000){  #sampling 1,000 random communities from the whole indivudal pool
  indv_list <- sample(levels(as.factor(Metradica_log$Code)), size = indv_rich_6, replace =FALSE) # first null community for class TWI 6 sampled from the whole dataset
  Data_6_abon <- c()
  for (s in 1:indv_rich_6){
    
    Data_6_abon <- rbind(Data_6_abon, 
                         Metradica_log[sample(which(Metradica_log$Code == indv_list[s]), 1),]) #constraining the null community to have the same abundance/same number of individuals as the community of class 6 
  }
  
  PCA_comm_6 <- PCA(Data_6_abon %>% dplyr::select(-Plot, -Forest,-Genus, -Species, -Name, -Type, -Habitat, -TWI, -DBH, -SD), scale.unit = TRUE, graph = FALSE)
  class_6 <- c(class_6, PCA_comm_6$eig[1,1] - PCA_comm_6$eig[8,1])
  class_6_sd <- c(class_6_sd , sd(PCA_comm_6$eig[,1]))
}

plot_6 <- hist(class_6)

ITI_6 <- (range_6 - mean(class_6))/sd(class_6)
ITI_6_sd <- (sd_6 - mean(class_6_sd))/sd(class_6_sd)

#####################
#Plots
#####################

#data for specialists
data_s <- data
data_s$ranges <- c(range_1, range_2, range_3, range_4, range_5, range_6)
data_s$sd <- c(sd_1, sd_2, sd_3, sd_4, sd_5, sd_6)
data_s$ITI <- c(ITI_1, ITI_2, ITI_3, ITI_4, ITI_5, ITI_6)
data_s$ITI_sd <- c(ITI_1_sd, ITI_2_sd, ITI_3_sd, ITI_4_sd, ITI_5_sd, ITI_6_sd)

#save data for specialists
write.csv(data_s, "./Results/TI/data_specialist.csv")

```

```{r specialist plot, message=FALSE, warning=FALSE, include=FALSE}
library(ggpubr)

# Calculate the proportion of TF and SF species in each class
proportions <- Metradica_log %>%
  group_by(class_TWI, Type) %>%
  summarise(count = n()) %>%
  spread(key = Type, value = count, fill = 0) %>%
  mutate(total = TF + BF,
         TF_prop = TF / total,
         BF_prop = BF / total)


#read previously saved file for specialists
data_s <- read.csv("./Results/TI/data_specialist.csv")


# Merge the proportions data with data_s
data_s <- left_join(data_s, proportions, by = c("class" = "class_TWI"))

#plot specialist
title_s <- "Specialist"

# Create a text grob
tgrob_s <- ggpubr::text_grob(title_s,size = 16)
# Draw the text
plot_s <- as_ggplot(tgrob_s) + theme(plot.margin = margin(0,3,0,0, "cm"))

plot_df = data.frame(x = 1:20, y = rnorm(20))

#Previous Plot TI (ranges standardized by effect size) along TWI 
C <- ggplot(data_s) +
  aes(x = mean, y = ITI,  ymax = ITI, ymin = 0) +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
   geom_pointrange(shape = "circle", size = 1, aes(color = mean)) +
  scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
  scale_fill_manual(values = c("#E79F02", "#56B4E9"), 
                    labels = c("TF", "SF"), 
                    name = "Species Type") +
  ylab(expression(atop("Trait integration index", italic("range")))) + #atop creates a line break
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12),aspect.ratio = 1 ) +
  theme_minimal(base_size = 12) +
  guides(color = "none") +#remove legend
    ylim(-4,6)+
  xlim(1.7, 2.6)
C


#Plot with piecharts the porportions (code based on https://stackoverflow.com/questions/43984614/rggplot2geom-points-how-to-swap-points-with-pie-charts)

data_s_2 <- data_s %>% 
  rowwise() %>%
  mutate(total = TF_prop + BF_prop) %>%
  pivot_longer(cols = c("TF_prop", "BF_prop"), names_to = "component", values_to = "value") %>%
  dplyr::select(mean, ITI, component, value, total)

# Create pie chart grobs
data_s.grobs <- data_s_2 %>%
  group_by(mean, ITI, total) %>%
  do(subplots = list(ggplot(., aes(1, value, fill = component)) + 
                       geom_col(position = "fill", alpha = 0.75, colour = "white") + 
                       coord_polar(theta = "y") + 
                        scale_fill_manual(values = c("#56B4E9", "#E79F02")) + # Set colors
                       theme_void() + 
                       guides(fill = FALSE))) %>%
  rowwise() %>%
  mutate(subgrobs = list(annotation_custom(ggplotGrob(subplots[[1]]), 
                      xmin = mean - total / 2, xmax = mean + total / 2, 
                      ymin = ITI - total / 2, ymax = ITI + total / 2)))

data_s.grobs


#Plot
base_plot <- ggplot(data_s) +
  aes(x = mean, y = ITI) +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
  ylab(expression(atop("Trait integration index", italic("range")))) + 
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12)) +
  theme_minimal(base_size = 12) +
  guides(color = "none") + 
  ylim(-4, 6) +
  xlim(1.7, 2.6)

#Add pie charts as custom annotations
for (i in 1:nrow(data_s.grobs)) {
  base_plot <- base_plot +
    data_s.grobs$subgrobs[[i]]
}

# Display the plot
print(base_plot)

# Add vertical lines from each pie chart to y = 0
C_new <- base_plot +
  geom_segment(data = data_s,
               aes(x = mean, xend = mean, y = ITI, yend = 0),
               linetype = "solid", color = "grey", size = 0.5)

C_new

#Previous plot TI_sd along TWI
D <- ggplot(data_s) +
  aes(x = mean, y = ITI_sd, ymax= ITI_sd, ymin=0) +
  geom_pointrange(shape = "circle", size = 1, aes(color = mean)) +
  scale_color_gradient(low = "#E79F02", high = "#56B4E9") +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
  ylab(expression(atop("Trait integration index", italic("standard deviation")))) +
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12)) +
  theme_minimal(base_size = 12)+
  guides(color = "none")+
  ylim(-4, 6)+
  xlim(1.7, 2.6)
D

#Plot with piecharts the specialist proportions
data_s_2 <- data_s %>% 
  rowwise() %>%
  mutate(total = TF_prop + BF_prop) %>%
  pivot_longer(cols = c("TF_prop", "BF_prop"), names_to = "component", values_to = "value") %>%
  dplyr::select(mean, ITI_sd, component, value, total)

# Create pie chart grobs
data_s.grobs_sd <- data_s_2 %>%
  group_by(mean, ITI_sd, total) %>%
  do(subplots = list(ggplot(., aes(1, value, fill = component)) + 
                       geom_col(position = "fill", alpha = 0.75, colour = "white") + 
                       coord_polar(theta = "y") + 
                        scale_fill_manual(values = c("#56B4E9", "#E79F02")) + # Set colors
                       theme_void() + 
                       guides(fill = FALSE))) %>%
  rowwise() %>%
  mutate(subgrobs = list(annotation_custom(ggplotGrob(subplots[[1]]), 
                      xmin = mean - total / 2, xmax = mean + total / 2, 
                      ymin = ITI_sd - total / 2, ymax = ITI_sd + total / 2)))

data_s.grobs_sd

#Plot
base_plot_D <- ggplot(data_s) +
  aes(x = mean, y = ITI_sd) +
  geom_hline(yintercept = 0, col = "gray", linetype = "dashed") +
  ylab(expression(atop("Trait integration index", italic("standard deviation")))) + 
  xlab("Topographic wetness index") +
  theme(axis.text = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12)) +
  theme_minimal(base_size = 12) +
  guides(color = "none") + 
  ylim(-4, 6) +
  xlim(1.7, 2.6)

#Add pie charts as custom annotations
for (i in 1:nrow(data_s.grobs_sd)) {
  base_plot_D <- base_plot_D +
    data_s.grobs_sd$subgrobs[[i]]
}


# Add vertical lines from each pie chart to y = 0
D_new <- base_plot_D +
  geom_segment(data = data_s,
               aes(x = mean, xend = mean, y = ITI_sd, yend = 0),
               linetype = "solid", color = "grey", size = 0.5)

D_new
```

```{r both, echo=FALSE}

#arrange plots specialist and generalist together
plot_generalists <- ggpubr::ggarrange(plot_0, NULL, A, B, labels = c("", "", "A", "B"), ncol = 2, nrow = 2, common.legend = TRUE, heights = c(1,5))


plot_specialists <- ggpubr::ggarrange(plot_s, NULL, C_new, D_new, labels = c("", "", "C", "D"), ncol = 2, nrow = 2, common.legend = TRUE, heights = c(1,5))

plot_publi <- ggpubr::ggarrange(plot_generalists, plot_specialists, ncol = 1, nrow = 2)
plot_publi

#save plot
ggsave(filename = "Multivariate covariation_6 class.png", plot = plot_publi, bg = "white", width = 8, height = 7, dpi = 600)
```


Both multivariate indices (the range and standard deviation) show a strong increase towards the end of the TWI gradient, seasonally flooded soils (Figure 4). For generalist species, we observe a higher degree of trait association in both extreme ends of the TWI gradient (Figure 4A, 4B). For specialist species, trait integration is highest for individuals sampled in seasonally flooded soils (i.e. SF specialists) than for individuals sampled in terra firme soils (i.e. TF specialists) (Figure 4C, 4D). Seasonally flooded habitats act as a stronger environmental constraint than terra firme habitats on leaf trait syndromes linked to nutrient and water resources.

## Figure 3 - Intraspecific trait variability

**(H3) Generalist species express a higher intraspecific trait variability than specialist species.**

CV to quantify ITV : absolute variation of the intraspecific trait with respect to the interspecific mean. 

CV is defined as the ratio of the standard deviation \sigma to the mean , expressed as a percentage. CV is convenient to compare variation of traits among species as it requires no ad hoc assumptions and is unitless. 

```{r echo=FALSE, message=FALSE, warning=FALSE}


## CV


cv_eff <- function(traits){
  if(any(is.na(traits)))
    traits=traits[!is.na(traits)]
  N=length(traits)
  y_bar=mean(traits)
  s2_hat=var(traits)
  cv_2=s2_hat/y_bar^2
  cv_1=sqrt(cv_2)
  gamma_1=sum(((traits-y_bar)/s2_hat^0.5)^3)/N
  gamma_2=sum(((traits-y_bar)/s2_hat^0.5)^4)/N
  bias=cv_2^(3/2)/N*(3*cv_2^0.5-2*gamma_1)
  bias2=cv_1^3/N-cv_1/4/N-cv_1^2*gamma_1/2/N-cv_1*gamma_2/8/N
  cv1=sd(traits)/mean(traits)
  cv4=cv_1-bias2
  re=cv4
  return(list(cv= re, eff = N))
} 


cv <- function(traits){
  if(any(is.na(traits)))
    traits=traits[!is.na(traits)]
  N=length(traits)
  y_bar=mean(traits)
  s2_hat=var(traits)
  cv_2=s2_hat/y_bar^2
  cv_1=sqrt(cv_2)
  gamma_1=sum(((traits-y_bar)/s2_hat^0.5)^3)/N
  gamma_2=sum(((traits-y_bar)/s2_hat^0.5)^4)/N
  bias=cv_2^(3/2)/N*(3*cv_2^0.5-2*gamma_1)
  bias2=cv_1^3/N-cv_1/4/N-cv_1^2*gamma_1/2/N-cv_1*gamma_2/8/N
  cv1=sd(traits)/mean(traits)
  cv4=cv_1-bias2
  re=cv4
  return(re)
}



#data ----------
Metradica <- read.csv("Dataset/OUTPUT_cleaning/Subset_imputed/Subset_imputation_exceptSD_18042023.csv") 

Metradica$Type <- as.character(Metradica$Type)
Metradica$Name <- as.character(Metradica$Name)

# For generalists ----------
cv_G <- Metradica %>% filter(Type =="Generalist") %>% 
  rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Carbon", "Nitrogen", "Phosphorus", "Potassium"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), log) %>% 
  mutate(TLP = -TLP) %>%
  group_by(Name) %>% 
  summarise_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), funs(cv))

cv_G <- bind_rows(cv_G,
                  ungroup(cv_G) %>%
                  summarise_all(mean) %>%
                  mutate(Name = "mean"))

cv_long_G <- reshape2::melt(cv_G, "Name", variable.name = "trait", value.name = "CV")

cv_long_G$Type <- c("Generalist")

#for generalists collected in SF

cv_G_SF <- Metradica %>% filter(Type =="Generalist") %>% 
  filter(Habitat == "BF") %>%
  rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Carbon", "Nitrogen", "Phosphorus", "Potassium"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), log) %>% 
  mutate(TLP = -TLP) %>%
  group_by(Name) %>% 
  summarise_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), funs(cv))

cv_G_SF <- bind_rows(cv_G_SF,
                  ungroup(cv_G_SF) %>%
                  summarise_all(mean) %>%
                  mutate(Name = "mean"))

cv_long_G_SF <- reshape2::melt(cv_G_SF, "Name", variable.name = "trait", value.name = "CV")

cv_long_G_SF$Type <- c("Generalist")
cv_long_G_SF$Habitat <- c("BF")

#for generalists collected in TF
cv_G_TF <- Metradica %>% filter(Type =="Generalist") %>% 
  filter(Habitat == "TF") %>%
  rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD", "Carbon", "Nitrogen", "Phosphorus", "Potassium"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), log) %>% 
  mutate(TLP = -TLP) %>%
  group_by(Name) %>% 
  summarise_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), funs(cv))

cv_G_TF <- bind_rows(cv_G_TF,
                  ungroup(cv_G_TF) %>%
                  summarise_all(mean) %>%
                  mutate(Name = "mean"))

cv_long_G_TF <- reshape2::melt(cv_G_TF, "Name", variable.name = "trait", value.name = "CV")

cv_long_G_TF$Type <- c("Generalist")
cv_long_G_TF$Habitat <- c("TF")


# For TF specialist -------------

cv_TF <- Metradica %>% filter(Type =="TF") %>%
  rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
    mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), log) %>% 
  mutate(TLP = -TLP)%>%
  group_by(Name) %>% 
  summarise_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), funs(cv))


cv_TF <- bind_rows(cv_TF,
                   ungroup(cv_TF) %>% 
                  summarise_all(mean) %>% 
                  mutate(Name = "mean"))

cv_TF$SD[7] <- (cv_TF$SD[1]+cv_TF$SD[2]+cv_TF$SD[3]+cv_TF$SD[5]+cv_TF$SD[6])/5

cv_long_TF <- reshape2::melt(cv_TF, "Name", variable.name = "trait", value.name = "CV")

cv_long_TF$Type <- c("TF")
cv_long_TF$Habitat <- c("TF")

# For BF specialist-----------

cv_BF <-  Metradica %>% filter(Type =="BF") %>% 
   rename(Carbon = C,
         Nitrogen = N,
         Potassium = K, 
         Phosphorus = P) %>% 
    mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), abs) %>% 
  mutate_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), log) %>% 
  mutate(TLP = -TLP)%>%
  group_by(Name) %>% 
  summarise_at(c("Gmin","TLP", "LSWC", "MajVLA", "SD",  "Carbon", "Nitrogen", "Phosphorus", "Potassium"), funs(cv))

cv_BF <- bind_rows(cv_BF,
                ungroup(cv_BF) %>% 
                  summarise_all(mean) %>% 
                  mutate(Name = "mean")) 

cv_BF$SD[10] <- (cv_BF$SD[2]+cv_BF$SD[3]+cv_BF$SD[4]+cv_BF$SD[5]+cv_BF$SD[6]+cv_BF$SD[7]+cv_BF$SD[8]+cv_BF$SD[9])/8

cv_long_BF <- reshape2::melt(cv_BF, "Name", variable.name = "trait", value.name = "CV") 

cv_long_BF$Type <- c("BF")
cv_long_BF$Habitat <- c("BF")

cv_tot <- bind_rows(cv_long_BF, cv_long_TF, cv_long_G_SF, cv_long_G_TF) 

# plot all 
#option 1
cv_plot <- cv_tot %>% 
  mutate(CV =CV*100) %>%
  mutate(trait = dplyr::recode(trait, "Gmin" = "g[min]", "TLP" = "pi[tlp]")) %>%
  filter(Name != "mean") %>% 
  ggplot(aes(x = Type, y = CV, fill = Type)) +
  geom_jitter() + 
  geom_boxplot(alpha=0.7)+
  scale_fill_manual("Species'\npreference", 
                    values = c("#56B4E9", "#009E72",  "#E79F02"), 
                    labels = c("TF" = "TF specialist",
                               "Generalist" = "Generalist", 
                               "BF" = "SF specialist")) +
  scale_shape_discrete("Species'\npreference") +
  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+
  theme(plot.title = element_text(size=14, face="bold")) +
  ylab("Coefficient of variation (%)") + xlab("")+
    theme_minimal(base_size = 22) +
  facet_wrap(~trait, scales ="free_y") +
  theme(legend.position = "bottom")

#option 2
cv_tot$Type <- dplyr::recode(cv_tot$Type, "TF" = "TF specialist", "BF" = "SF specialist")

cv_plot <- cv_tot %>% 
  # mutate(trait = dplyr::recode(trait, "Gmin" = "g[min]", "TLP" = "TLP", "C"= "C", "N" = "N", "K"= "K", "LSWC" = "LSWC", "MajVLA" = "MajVLA", "P" = "P", "SD" = "SD")) %>%
   mutate(trait = dplyr::recode(trait, 
                                "Gmin" = "g[min]", 
                                "TLP" = "TLP", 
                                "Carbon"= "Carbon", 
                                "Nitrogen" = "Nitrogen", 
                                "Potassium"= "Potassium", 
                                "LSWC" = "LSWC", 
                                "MajVLA" = "MajVLA", 
                                "Phosphorus" = "Phosphorus", 
                                "SD" = "SD")) %>%
  mutate(CV =CV*100) %>%
  filter(Name != "mean") %>% 
  ggplot(aes(x = Type, y = CV, color = Type)) +
  #geom_point()+
  geom_jitter(size = 2) +
  scale_color_manual(
    values = c(Generalist = "#009E72",
    `SF specialist` = "#56B4E9",
    `TF specialist` = "#E79F02")
  ) +
  scale_shape_discrete("Species'\npreference") +
  theme_minimal(base_size = 12) +
   theme(axis.text.x = element_blank())+
    theme(plot.title = element_text(size=12, face="bold")) +
  facet_wrap(~trait, scales ="free_y", labeller = label_parsed) +
  labs(x = "", y = "Coefficient of variation (%)", color = "Species' preference") +
  theme(legend.position = "bottom")
 

cv_plot

#option 3
#add habitat of collect information for better plotting

cv_tot$Type <- dplyr::recode(cv_tot$Type,"TF"= "TF specialist", "BF" = "SF specialist")
cv_tot$Habitat <- dplyr::recode(cv_tot$Habitat,"TF"="Terra firme", "BF"="Seasonally flooded")

max_y <- max(cv_tot$CV * 100, na.rm = TRUE)

cv_plot <- cv_tot %>%
 mutate(CV =CV*100) %>%
  filter(Name != "mean") %>% 
ggplot()+
  aes(x = Habitat, y = CV, color = Type) +
  #geom_point()+
  geom_jitter(size = 2, width = 0.2) +
  scale_color_manual(
    values = c(Generalist = "#009E72",
    `SF specialist` = "#56B4E9",
    `TF specialist` = "#E79F02")
  ) +
  scale_shape_discrete("Habitat of collect") +
  theme_minimal(base_size = 12) +
  # theme(axis.text.x = element_blank())+
    theme(plot.title = element_text(size=12, face="bold")) +
  facet_wrap(~trait, scales ="free_y", labeller = label_parsed) +
  labs(x = "", y = "Coefficient of variation (%)", color = "Species' preference") +
  theme(legend.position = "bottom")+
  ylim(0, max_y)


cv_plot

ggsave(filename = "CV_plot.png", plot = cv_plot, bg = "white", width = 8, height = 6, dpi = 600)


#option 4

#mean data
mean_data <- cv_tot %>%
   filter(Name == "mean") %>%
    mutate(trait = dplyr::recode(trait, "Gmin" = "g[min]")) 

cv_data <- cv_tot %>%
   mutate(trait = dplyr::recode(trait, "Gmin" = "g[min]")) %>%
   filter(Name != "mean") %>% 
  tidyr::separate(Name, c("Genus", "Species"), sep = "_", remove = F) %>%
    mutate(Taxa = paste0(substr(Genus, start=1, stop=1), ". ", Species)) %>%
 mutate(CV =CV*100)

#to jitter points according to first Habitat and then Type:

# Create a mapping for Type to adjust the x positions
type_adjustment <- c(
  "Generalist" = -0.2,
  "SF specialist" = 0.2,
  "TF specialist" = 0.2
)

# Adjust the x positions slightly based on the Type within each Habitat
cv_data <- cv_data %>%
  mutate(Habitat_Adjusted = as.numeric(as.factor(Habitat)) + type_adjustment[Type])

# Create a jitter object with the desired horizontal jitter width
jitter <- position_jitter(width = 0.05, height = 0)

cv_plot <- ggplot() +
  geom_boxplot(data = cv_data, aes(x = as.factor(as.numeric(as.factor(Habitat))), y = CV, color = Type)) +
  geom_point(data = cv_data, aes(x = Habitat_Adjusted, y = CV, shape = Taxa, color = Type), 
             size = 2.3, alpha = 0.7, position = jitter) +
  scale_color_manual(values = c(Generalist = "#009E72",
                                `SF specialist` = "#56B4E9",
                                `TF specialist` = "#E79F02")) +
  scale_shape_manual(values = c("C. surinamensis" = 0, "E. falcata" = 1, "E. coriacea" = 2, "I. hostmannii" = 3, 
                                "L. procera" = 4, "P. opacum subsp. rabelianum" = 5, "P. officinalis" = 6, 
                                "S. globulifera" = 7, "V. surinamensis" = 8, "D. guianensis" = 9, 
                                "G. hexapetala" = 10, "I. sagotiana" = 11, "L. membranacea" = 12,  
                                "P. guianensis" = 13, "V. michelii" = 14, "B. prouacensis" = 15,  
                                "C. guianensis" = 16, "H. heteromorphus" = 17, 
                                "J. copaia subsp. copaia" = 18, "P. stevensonii" = 19,  
                                "T. melinonii" = 20)) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(size = 12, face = "bold")) +
  facet_wrap(~trait, scales = "free_y", labeller = label_parsed) +
  labs(x = "", y = "Coefficient of variation (%)", color = "Species' preference", shape = "Species") +
  guides(
    color = guide_legend(order = 1),
    shape = guide_legend(order = 2, ncol = 5, byrow = TRUE, title.position = "top")
  ) +
  theme(legend.box = "vertical", legend.position = "bottom", legend.text = element_text(face = "italic")) +
  ylim(0, max_y)+
  scale_x_discrete(labels=c("1" = "Seasonally flooded", "2" = "Terra firme"))

cv_plot

ggsave(filename = "CV_plot.png", plot = cv_plot, bg = "white", width = 9, height = 8, dpi = 600)
```


Leaf traits showed non-negligeable CV within species for all preferences (Figure 5). The lowest CVs are observed for leaf carbon concentration (0.9 % for SF specialists ; 1.1 % for TF specialists and 1.3 % for generalists), but also LSWC and SD. Moderate CVs are observed for TLP, MajVLA and leaf potassium concentration. The highest CV are observed for gmin, with 68% for SF specialists, and 60 % for TF specialists. Generalist species do not necessarily exhibit a higher CV compared to specialist species (Figure 5), but this was the case for leaf potassium concentration (6 generalist species), LSWC (3 generalist species), leaf nitrogen concentration (2 generalist species), P (1 generalist species).